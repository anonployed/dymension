package types_test

import (
	"testing"

	"cosmossdk.io/math"
	"github.com/dymensionxyz/dymension/v3/x/iro/types"
	"github.com/stretchr/testify/require"
)

func TestBondingCurveIntegral(t *testing.T) {
	m := math.NewInt(2)
	n := math.NewInt(2)
	c := math.NewInt(1)
	bondingCurve := types.NewBondingCurve(m, c, n)

	// Test case 1: x = 0
	x := math.NewInt(0)
	expected := math.NewInt(0)
	result := bondingCurve.Integral(x)
	require.Equal(t, expected, result)

	// Test case 2: x = 1
	x = math.NewInt(1)
	expected = math.NewInt(3)
	result = bondingCurve.Integral(x)
	require.Equal(t, expected, result)

	// Test case 3: x = 2
	x = math.NewInt(2)
	expected = math.NewInt(14)
	result = bondingCurve.Integral(x)
	require.Equal(t, expected, result)

	// Test case 4: x = 3
	x = math.NewInt(3)
	expected = math.NewInt(39)
	result = bondingCurve.Integral(x)
	require.Equal(t, expected, result)
}

// y=mx^n+c
// m >= 0, c > 0
func TestBondingCurve_ValidateBasic(t *testing.T) {
	tests := []struct {
		name      string
		m         int64
		n         int64
		c         int64
		expectErr bool
	}{
		{
			name: "Valid bonding curve",
			m:    2,
			n:    2,
			c:    3,
		},
		{
			name: "Valid linear curve",
			m:    2,
			n:    1,
			c:    3,
		},
		{
			name: "Valid const price curve",
			m:    0,
			n:    1,
			c:    3,
		},
		{
			name:      "Invalid C value",
			m:         2,
			n:         1,
			c:         0,
			expectErr: true,
		},
		{
			name:      "Invalid M value",
			m:         -2,
			n:         1,
			c:         3,
			expectErr: true,
		},
		{
			name:      "Invalid N value",
			m:         2,
			n:         -1,
			c:         3,
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			bondingCurve := types.NewBondingCurve(math.NewInt(tt.m), math.NewInt(tt.n), math.NewInt(tt.c))
			err := bondingCurve.ValidateBasic()
			if tt.expectErr {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
			}
		})
	}
}

// simple linear curve
func TestBondingCurve_SpotPrice(t *testing.T) {
	m := math.NewInt(1)
	n := math.NewInt(1)
	c := math.NewInt(0)
	curve := NewBondingCurve(m, c, n)

	// Test values
	x1 := math.NewInt(0)
	x2 := math.NewInt(10)
	x3 := math.NewInt(100)

	// Expected results
	spotPrice1 := math.NewInt(0)   // 1*0^1 + 0
	spotPrice2 := math.NewInt(10)  // 1*10^1 + 0
	spotPrice3 := math.NewInt(100) // 1*100^1 + 0

	cost1to2 := math.NewInt(50)   // (1/2)*10^2 - (1/2)*0^2
	cost2to3 := math.NewInt(4950) // (1/2)*100^2 - (1/2)*10^2
}

// Scenario 2: Quadratic Curve with Offset
func TestBondingCurve_Quadratic(t *testing.T) {
	m := math.NewInt(2)
	n := math.NewInt(2)
	c := math.NewInt(10)
	curve := NewBondingCurve(m, c, n)

	// Test values
	x1 := math.NewInt(0)
	x2 := math.NewInt(5)
	x3 := math.NewInt(10)

	// Expected results
	spotPrice1 := math.NewInt(10)  // 2*0^2 + 10
	spotPrice2 := math.NewInt(60)  // 2*5^2 + 10
	spotPrice3 := math.NewInt(210) // 2*10^2 + 10

	cost1to2 := math.NewInt(183) // (2/3)*5^3 + 10*5 - (2/3)*0^3 - 10*0
	cost2to3 := math.NewInt(883) // (2/3)*10^3 + 10*10 - (2/3)*5^3 - 10*5
}

// Scenario 3: Cubic Curve with Large Numbers
func TestBondingCurve_Cubic(t *testing.T) {

	m := math.NewInt(3)
	n := math.NewInt(3)
	c := math.NewInt(1000)
	curve := NewBondingCurve(m, c, n)

	// Test values
	x1 := math.NewInt(0)
	x2 := math.NewInt(100)
	x3 := math.NewInt(1000)

	// Expected results
	spotPrice1 := math.NewInt(1000)       // 3*0^3 + 1000
	spotPrice2 := math.NewInt(3001000)    // 3*100^3 + 1000
	spotPrice3 := math.NewInt(3000001000) // 3*1000^3 + 1000

	cost1to2 := math.NewInt(75250000)     // (3/4)*100^4 + 1000*100 - (3/4)*0^4 - 1000*0
	cost2to3 := math.NewInt(750002500000) // (3/4)*1000^4 + 1000*1000 - (3/4)*100^4 - 1000*100
}

// Scenario 4: High Exponent
func TestBondingCurve_HighExponent(t *testing.T) {
	m := math.NewInt(1)
	n := math.NewInt(5)
	c := math.NewInt(100)
	curve := NewBondingCurve(m, c, n)

	// Test values
	x1 := math.NewInt(0)
	x2 := math.NewInt(2)
	x3 := math.NewInt(10)

	// Expected results
	spotPrice1 := math.NewInt(100)    // 1*0^5 + 100
	spotPrice2 := math.NewInt(132)    // 1*2^5 + 100
	spotPrice3 := math.NewInt(100100) // 1*10^5 + 100

	cost1to2 := math.NewInt(310)    // (1/6)*2^6 + 100*2 - (1/6)*0^6 - 100*0
	cost2to3 := math.NewInt(166890) // (1/6)*10^6 + 100*10 - (1/6)*2^6 - 100*2
}
